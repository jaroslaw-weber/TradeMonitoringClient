@page "/"

@using TradeMonitoringClient.Data;
@using Microsoft.Extensions.Logging;
@inject PositionDataService PositionDataService;
@inject ILogger<PositionTable> logger;

<h1>Position Monitoring</h1>

<p>Current price and quantity.</p>
<p>The data is updated every second.</p>


@if (data == null)
{
<p><em>Loading...</em></p> }
else
{
<div>

    <p>Last update: @data.TimestampString</p>
    <table class="table">
        <thead>
            <tr>
                <th>Position Id</th>
                <th>Ticker</th>
                <th>Spot Price</th>
                <th>Qty [T-1]</th>
                <th>Qty [T-0]</th>
                <th>Qty change</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var position in data.Positions)
            {
<tr>
    <td>@position.Id</td>
    <td>@position.Ticker</td>
    <td>@position.Price</td>
    <td>@position.DayStartQuantity</td>
    <td>@position.CurrentQuantity</td>
    <td style="color:@position.Color">@position.ChangeToday</td>
</tr>
           }
        </tbody>
    </table>
</div>}

@code
{ private PositionDataMessage data = null;

    protected override async Task OnInitializedAsync()
    {
        this.PositionDataService.Logger = this.logger;
        this.PositionDataService.OnDataReceived = OnDataReceivedFromServer;

        await this.PositionDataService.ConnectToServer();
        this.PositionDataService.StartLoop();

    }

    private async void OnDataReceivedFromServer(PositionDataMessage newData)
    {
        this.data = newData;
        data.Recalculate();

        logger.LogInformation("updating view");

        //workaround:
        //StateHasChanged has to be called with InvokeAsync
        //if not, it will block (only in callback
        await InvokeAsync(this.StateHasChanged);
    } }
