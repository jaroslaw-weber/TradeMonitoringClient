@page "/"

@using TradeMonitoringClient.Data;
@using Microsoft.Extensions.Logging;
@inject PositionDataService ForecastService;
@inject ILogger<PositionTable> logger;

<h1>Live Prices of Securities</h1>

<p>The data is updated every second.</p>

<p>Last update: @timestamp</p>

@if (data == null)
{
<p><em>Loading...</em></p>
}
else
{
<table class="table">
    <thead>
        <tr>
            <th>Position Id</th>
            <th>Ticker</th>
            <th>Spot Price</th>
            <th>Qty [T-1]</th>
            <th>Qty [T-0]</th>
            <th>Qty change</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var position in data.Positions)
        {
        <tr>
            <td>@position.Id</td>
            <td>@position.Ticker</td>
            <td>@position.Price</td>
            <td>@position.DayStartPosition</td>
            <td>@position.CurrentQuantity</td>
            <td>@position.ChangeToday</td>
        </tr>
}
    </tbody>
</table>}

@code
{
    private PositionDataMessage data;
    private string timestamp;

    protected override async Task OnInitializedAsync()
    {
        this.ForecastService.Logger = this.logger;
        this.ForecastService.OnDataReceived = OnDataReceivedFromServer;

        await this.ForecastService.ConnectToServer();
        this.ForecastService.StartLoop();

    }
    private async void OnDataReceivedFromServer(PositionDataMessage newData)
    {
        this.data = newData;

        //convert timestamp to string and cache to improve performance
        timestamp = newData.Timestamp.ToString();


        logger.LogInformation("updating view");

        //workaround:
        //StateHasChanged has to be called with InvokeAsync
        //if not, it will block (only in callback
        await InvokeAsync(this.StateHasChanged);
    }
}
    
