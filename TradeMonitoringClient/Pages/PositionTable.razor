@page "/"

@using TradeMonitoringClient.Data;
@using Microsoft.Extensions.Logging;
@inject PositionTableService PositionTableService;
@inject ILogger<PositionTable> logger;

<h1>Position Monitoring</h1>

<p>Current price and quantity.</p>
<p>The data is updated every second.</p>


@if (model.Data == null)
{
<p><em>Loading...</em></p> }
else
{
<div>

    <p>Last update: @model.TimestampString</p>
    <table class="table">
        <thead>
            <tr>
                <th>Position Id</th>
                <th>Ticker</th>
                <th>Spot Price</th>
                <th>Qty [T-1]</th>
                <th>Qty [T-0]</th>
                <th>Qty change</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var position in model.Data.Positions)
            {
<tr>
    <td>@position.Id</td>
    <td>@position.Ticker</td>
    <td>@position.Price</td>
    <td>@position.DayStartQuantity</td>
    <td>@position.CurrentQuantity</td>
    <td style="color:@position.Color">@position.ChangeToday</td>
</tr>
           }
        </tbody>
    </table>
</div>}

@code
{
    private PositionTablePageModel model = new();

    protected override async Task OnInitializedAsync()
    {
        //todo removing the event from handler with -= OnDataReceivedFromServer;
        this.PositionTableService.OnDataReceived += OnDataReceivedFromServer;

        //if loop is not running then start
        if (this.PositionTableService.IsRunning) return;
        this.PositionTableService.Logger = this.logger;
        await this.PositionTableService.ConnectToServer();
        this.PositionTableService.StartListeningToWebsocket();

    }

    private async void OnDataReceivedFromServer(PositionDataMessage newData)
    {
        this.model.OnDataReceived(newData);

        logger.LogInformation("updating view");

        //workaround:
        //StateHasChanged has to be called with InvokeAsync
        //if not, it will block (only in callback
        await InvokeAsync(this.StateHasChanged);
    }
}